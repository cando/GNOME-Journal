/* utils.c generated by valac 0.16.0, the Vala compiler
 * generated from utils.vala, do not modify */

/* This file is part of GNOME Activity Journal.*/

#include <glib.h>
#include <glib-object.h>
#include <gio/gio.h>
#include <libgnome-desktop/gnome-desktop-thumbnail.h>
#include <stdlib.h>
#include <string.h>
#include <config.h>
#include <gdk/gdk.h>
#include <clutter/clutter.h>
#include <float.h>
#include <math.h>
#include <gtk/gtk.h>
#include <gdk-pixbuf/gdk-pixbuf.h>


#define JOURNAL_TYPE_UTILS (journal_utils_get_type ())
#define JOURNAL_UTILS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), JOURNAL_TYPE_UTILS, JournalUtils))
#define JOURNAL_UTILS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), JOURNAL_TYPE_UTILS, JournalUtilsClass))
#define JOURNAL_IS_UTILS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), JOURNAL_TYPE_UTILS))
#define JOURNAL_IS_UTILS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), JOURNAL_TYPE_UTILS))
#define JOURNAL_UTILS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), JOURNAL_TYPE_UTILS, JournalUtilsClass))

typedef struct _JournalUtils JournalUtils;
typedef struct _JournalUtilsClass JournalUtilsClass;
typedef struct _JournalUtilsPrivate JournalUtilsPrivate;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _gtk_widget_path_unref0(var) ((var == NULL) ? NULL : (var = (gtk_widget_path_unref (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _Block4Data Block4Data;
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _JournalUtilsQueueThumbnailJobForFileAsyncData JournalUtilsQueueThumbnailJobForFileAsyncData;

struct _JournalUtils {
	GObject parent_instance;
	JournalUtilsPrivate * priv;
};

struct _JournalUtilsClass {
	GObjectClass parent_class;
};

struct _Block4Data {
	int _ref_count_;
	GSourceFunc callback;
	gpointer callback_target;
	GDestroyNotify callback_target_destroy_notify;
	gboolean _result_;
	GFile* file;
	gpointer _async_data_;
};

struct _JournalUtilsQueueThumbnailJobForFileAsyncData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	GFile* file;
	gboolean result;
	Block4Data* _data4_;
	GFile* _tmp0_;
	GFile* _tmp1_;
};


static gpointer journal_utils_parent_class = NULL;
extern GSettings* journal_utils_settings;
GSettings* journal_utils_settings = NULL;
static GnomeDesktopThumbnailFactory* journal_utils_factory;
static GnomeDesktopThumbnailFactory* journal_utils_factory = NULL;

GType journal_utils_get_type (void) G_GNUC_CONST;
enum  {
	JOURNAL_UTILS_DUMMY_PROPERTY
};
#define JOURNAL_UTILS_F11_KEY ((guint) 0xffc8)
#define JOURNAL_UTILS_ICON_VIEW_SIZE 128
#define JOURNAL_UTILS_LIST_VIEW_SIZE 48
gchar* journal_utils_get_pkgdata (const gchar* file_name);
gchar* journal_utils_get_style (const gchar* file_name);
void journal_utils_gdk_rgba_to_clutter_color (GdkRGBA* gdk_rgba, ClutterColor* result);
void journal_utils_get_journal_bg_color (GdkRGBA* result);
gint journal_utils_getIconSize (void);
static void journal_utils_queue_thumbnail_job_for_file_async_data_free (gpointer _data);
void journal_utils_queue_thumbnail_job_for_file_async (GFile* file, GAsyncReadyCallback _callback_, gpointer _user_data_);
gboolean journal_utils_queue_thumbnail_job_for_file_finish (GAsyncResult* _res_);
static gboolean journal_utils_queue_thumbnail_job_for_file_async_co (JournalUtilsQueueThumbnailJobForFileAsyncData* _data_);
static Block4Data* block4_data_ref (Block4Data* _data4_);
static void block4_data_unref (void * _userdata_);
static gboolean _journal_utils_queue_thumbnail_job_for_file_async_co_gsource_func (gpointer self);
static gboolean __lambda2_ (Block4Data* _data4_);
static gboolean ___lambda2__gio_scheduler_job_func (GIOSchedulerJob* job, GCancellable* cancellable, gpointer self);
JournalUtils* journal_utils_new (void);
JournalUtils* journal_utils_construct (GType object_type);
static void journal_utils_finalize (GObject* obj);


gchar* journal_utils_get_pkgdata (const gchar* file_name) {
	gchar* result = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_ = NULL;
	_tmp0_ = file_name;
	_tmp1_ = g_build_filename (PKGDATADIR, _tmp0_, NULL);
	result = _tmp1_;
	return result;
}


gchar* journal_utils_get_style (const gchar* file_name) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	const gchar* _tmp2_;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_;
	_tmp0_ = journal_utils_get_pkgdata (NULL);
	_tmp1_ = _tmp0_;
	_tmp2_ = file_name;
	_tmp3_ = g_build_filename (_tmp1_, "style", _tmp2_, NULL);
	_tmp4_ = _tmp3_;
	_g_free0 (_tmp1_);
	result = _tmp4_;
	return result;
}


void journal_utils_gdk_rgba_to_clutter_color (GdkRGBA* gdk_rgba, ClutterColor* result) {
	GdkRGBA _tmp0_;
	gdouble _tmp1_;
	gdouble _tmp2_ = 0.0;
	GdkRGBA _tmp3_;
	gdouble _tmp4_;
	gdouble _tmp5_ = 0.0;
	GdkRGBA _tmp6_;
	gdouble _tmp7_;
	gdouble _tmp8_ = 0.0;
	GdkRGBA _tmp9_;
	gdouble _tmp10_;
	gdouble _tmp11_ = 0.0;
	ClutterColor _tmp12_ = {0};
	ClutterColor color;
	g_return_if_fail (gdk_rgba != NULL);
	_tmp0_ = *gdk_rgba;
	_tmp1_ = _tmp0_.red;
	_tmp2_ = CLAMP (_tmp1_ * 255, (gdouble) 0, (gdouble) 255);
	_tmp3_ = *gdk_rgba;
	_tmp4_ = _tmp3_.green;
	_tmp5_ = CLAMP (_tmp4_ * 255, (gdouble) 0, (gdouble) 255);
	_tmp6_ = *gdk_rgba;
	_tmp7_ = _tmp6_.blue;
	_tmp8_ = CLAMP (_tmp7_ * 255, (gdouble) 0, (gdouble) 255);
	_tmp9_ = *gdk_rgba;
	_tmp10_ = _tmp9_.alpha;
	_tmp11_ = CLAMP (_tmp10_ * 255, (gdouble) 0, (gdouble) 255);
	_tmp12_.red = (guint8) _tmp2_;
	_tmp12_.green = (guint8) _tmp5_;
	_tmp12_.blue = (guint8) _tmp8_;
	_tmp12_.alpha = (guint8) _tmp11_;
	color = _tmp12_;
	*result = color;
	return;
}


void journal_utils_get_journal_bg_color (GdkRGBA* result) {
	GtkStyleContext* _tmp0_;
	GtkStyleContext* style;
	GtkWidgetPath* _tmp1_;
	GtkWidgetPath* path;
	GdkRGBA _tmp2_ = {0};
	_tmp0_ = gtk_style_context_new ();
	style = _tmp0_;
	_tmp1_ = gtk_widget_path_new ();
	path = _tmp1_;
	gtk_widget_path_append_type (path, GTK_TYPE_WINDOW);
	gtk_style_context_set_path (style, path);
	gtk_style_context_add_class (style, "theme_bg_color");
	gtk_style_context_get_background_color (style, 0, &_tmp2_);
	*result = _tmp2_;
	_gtk_widget_path_unref0 (path);
	_g_object_unref0 (style);
	return;
}


gint journal_utils_getIconSize (void) {
	gint result = 0;
	result = JOURNAL_UTILS_ICON_VIEW_SIZE;
	return result;
}


static void journal_utils_queue_thumbnail_job_for_file_async_data_free (gpointer _data) {
	JournalUtilsQueueThumbnailJobForFileAsyncData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->file);
	g_slice_free (JournalUtilsQueueThumbnailJobForFileAsyncData, _data_);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


void journal_utils_queue_thumbnail_job_for_file_async (GFile* file, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	JournalUtilsQueueThumbnailJobForFileAsyncData* _data_;
	GFile* _tmp0_;
	GFile* _tmp1_;
	_data_ = g_slice_new0 (JournalUtilsQueueThumbnailJobForFileAsyncData);
	_data_->_async_result = g_simple_async_result_new (g_object_newv (G_TYPE_OBJECT, 0, NULL), _callback_, _user_data_, journal_utils_queue_thumbnail_job_for_file_async);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, journal_utils_queue_thumbnail_job_for_file_async_data_free);
	_tmp0_ = file;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_data_->file = _tmp1_;
	journal_utils_queue_thumbnail_job_for_file_async_co (_data_);
}


gboolean journal_utils_queue_thumbnail_job_for_file_finish (GAsyncResult* _res_) {
	gboolean result;
	JournalUtilsQueueThumbnailJobForFileAsyncData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
	result = _data_->result;
	return result;
}


static Block4Data* block4_data_ref (Block4Data* _data4_) {
	g_atomic_int_inc (&_data4_->_ref_count_);
	return _data4_;
}


static void block4_data_unref (void * _userdata_) {
	Block4Data* _data4_;
	_data4_ = (Block4Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data4_->_ref_count_)) {
		(_data4_->callback_target_destroy_notify == NULL) ? NULL : (_data4_->callback_target_destroy_notify (_data4_->callback_target), NULL);
		_data4_->callback = NULL;
		_data4_->callback_target = NULL;
		_data4_->callback_target_destroy_notify = NULL;
		_g_object_unref0 (_data4_->file);
		g_slice_free (Block4Data, _data4_);
	}
}


static gboolean _journal_utils_queue_thumbnail_job_for_file_async_co_gsource_func (gpointer self) {
	gboolean result;
	result = journal_utils_queue_thumbnail_job_for_file_async_co (self);
	return result;
}


static gboolean __lambda2_ (Block4Data* _data4_) {
	gboolean result = FALSE;
	GdkPixbuf* pixbuf;
	GFileInfo* info = NULL;
	GFile* _tmp0_;
	gchar* _tmp1_ = NULL;
	gchar* uri;
	GFileInfo* _tmp14_;
	guint64 _tmp15_ = 0ULL;
	guint64 mtime;
	GFileInfo* _tmp16_;
	const gchar* _tmp17_ = NULL;
	gchar* _tmp18_;
	gchar* mime_type;
	const gchar* _tmp19_;
	GdkPixbuf* _tmp25_;
	GSourceFunc _tmp30_;
	void* _tmp30__target;
	GDestroyNotify _tmp30__target_destroy_notify;
	GError * _inner_error_ = NULL;
	pixbuf = NULL;
	_tmp0_ = _data4_->file;
	_tmp1_ = g_file_get_uri (_tmp0_);
	uri = _tmp1_;
	{
		GFile* _tmp2_;
		GFileInfo* _tmp3_ = NULL;
		GFileInfo* _tmp4_;
		_tmp2_ = _data4_->file;
		_tmp3_ = g_file_query_info (_tmp2_, G_FILE_ATTRIBUTE_TIME_MODIFIED "," G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE, 0, NULL, &_inner_error_);
		_tmp4_ = _tmp3_;
		if (_inner_error_ != NULL) {
			goto __catch6_g_error;
		}
		_g_object_unref0 (info);
		info = _tmp4_;
	}
	goto __finally6;
	__catch6_g_error:
	{
		GError* e = NULL;
		const gchar* _tmp5_;
		gchar* _tmp6_;
		gchar* _tmp7_;
		gchar* _tmp8_;
		gchar* _tmp9_;
		GError* _tmp10_;
		const gchar* _tmp11_;
		gchar* _tmp12_;
		gchar* _tmp13_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp5_ = uri;
		_tmp6_ = g_strconcat ("Unable to query info for file at ", _tmp5_, NULL);
		_tmp7_ = _tmp6_;
		_tmp8_ = g_strconcat (_tmp7_, ": ", NULL);
		_tmp9_ = _tmp8_;
		_tmp10_ = e;
		_tmp11_ = _tmp10_->message;
		_tmp12_ = g_strconcat (_tmp9_, _tmp11_, NULL);
		_tmp13_ = _tmp12_;
		g_warning ("utils.vala:68: %s", _tmp13_);
		_g_free0 (_tmp13_);
		_g_free0 (_tmp9_);
		_g_free0 (_tmp7_);
		_data4_->_result_ = FALSE;
		result = FALSE;
		_g_error_free0 (e);
		_g_free0 (uri);
		_g_object_unref0 (info);
		_g_object_unref0 (pixbuf);
		return result;
	}
	__finally6:
	if (_inner_error_ != NULL) {
		_g_free0 (uri);
		_g_object_unref0 (info);
		_g_object_unref0 (pixbuf);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	_tmp14_ = info;
	_tmp15_ = g_file_info_get_attribute_uint64 (_tmp14_, G_FILE_ATTRIBUTE_TIME_MODIFIED);
	mtime = _tmp15_;
	_tmp16_ = info;
	_tmp17_ = g_file_info_get_content_type (_tmp16_);
	_tmp18_ = g_strdup (_tmp17_);
	mime_type = _tmp18_;
	_tmp19_ = mime_type;
	if (_tmp19_ != NULL) {
		GnomeDesktopThumbnailFactory* _tmp20_;
		const gchar* _tmp21_;
		const gchar* _tmp22_;
		GdkPixbuf* _tmp23_ = NULL;
		GdkPixbuf* _tmp24_;
		_tmp20_ = journal_utils_factory;
		_tmp21_ = uri;
		_tmp22_ = mime_type;
		_tmp23_ = gnome_desktop_thumbnail_factory_generate_thumbnail (_tmp20_, _tmp21_, _tmp22_);
		_tmp24_ = _g_object_ref0 (_tmp23_);
		_g_object_unref0 (pixbuf);
		pixbuf = _tmp24_;
	} else {
		_data4_->_result_ = FALSE;
	}
	_tmp25_ = pixbuf;
	if (_tmp25_ != NULL) {
		GnomeDesktopThumbnailFactory* _tmp26_;
		GdkPixbuf* _tmp27_;
		const gchar* _tmp28_;
		guint64 _tmp29_;
		_tmp26_ = journal_utils_factory;
		_tmp27_ = pixbuf;
		_tmp28_ = uri;
		_tmp29_ = mtime;
		gnome_desktop_thumbnail_factory_save_thumbnail (_tmp26_, _tmp27_, _tmp28_, (gulong) _tmp29_);
		_data4_->_result_ = TRUE;
	} else {
		_data4_->_result_ = FALSE;
	}
	_tmp30_ = _data4_->callback;
	_tmp30__target = _data4_->callback_target;
	_tmp30__target_destroy_notify = _data4_->callback_target_destroy_notify;
	_data4_->callback_target_destroy_notify = NULL;
	g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, _tmp30_, _tmp30__target, _tmp30__target_destroy_notify);
	result = FALSE;
	_g_free0 (mime_type);
	_g_free0 (uri);
	_g_object_unref0 (info);
	_g_object_unref0 (pixbuf);
	return result;
}


static gboolean ___lambda2__gio_scheduler_job_func (GIOSchedulerJob* job, GCancellable* cancellable, gpointer self) {
	gboolean result;
	result = __lambda2_ (self);
	return result;
}


static gboolean journal_utils_queue_thumbnail_job_for_file_async_co (JournalUtilsQueueThumbnailJobForFileAsyncData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_data4_ = g_slice_new0 (Block4Data);
	_data_->_data4_->_ref_count_ = 1;
	_data_->_tmp0_ = _data_->file;
	_data_->_tmp1_ = _g_object_ref0 (_data_->_tmp0_);
	_data_->_data4_->file = _data_->_tmp1_;
	_data_->_data4_->_async_data_ = _data_;
	_data_->_data4_->callback = _journal_utils_queue_thumbnail_job_for_file_async_co_gsource_func;
	_data_->_data4_->callback_target = _data_;
	_data_->_data4_->callback_target_destroy_notify = NULL;
	_data_->_data4_->_result_ = FALSE;
	g_io_scheduler_push_job (___lambda2__gio_scheduler_job_func, block4_data_ref (_data_->_data4_), block4_data_unref, G_PRIORITY_DEFAULT, NULL);
	_data_->_state_ = 1;
	return FALSE;
	_state_1:
	;
	_data_->result = _data_->_data4_->_result_;
	block4_data_unref (_data_->_data4_);
	_data_->_data4_ = NULL;
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
	block4_data_unref (_data_->_data4_);
	_data_->_data4_ = NULL;
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


JournalUtils* journal_utils_construct (GType object_type) {
	JournalUtils * self = NULL;
	self = (JournalUtils*) g_object_new (object_type, NULL);
	return self;
}


JournalUtils* journal_utils_new (void) {
	return journal_utils_construct (JOURNAL_TYPE_UTILS);
}


static void journal_utils_class_init (JournalUtilsClass * klass) {
	GSettings* _tmp0_;
	GnomeDesktopThumbnailFactory* _tmp1_;
	journal_utils_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->finalize = journal_utils_finalize;
	_tmp0_ = g_settings_new ("org.gnome.activity-journal");
	_g_object_unref0 (journal_utils_settings);
	journal_utils_settings = _tmp0_;
	_tmp1_ = gnome_desktop_thumbnail_factory_new (GNOME_DESKTOP_THUMBNAIL_SIZE_NORMAL);
	_g_object_unref0 (journal_utils_factory);
	journal_utils_factory = _tmp1_;
}


static void journal_utils_instance_init (JournalUtils * self) {
}


static void journal_utils_finalize (GObject* obj) {
	JournalUtils * self;
	self = JOURNAL_UTILS (obj);
	G_OBJECT_CLASS (journal_utils_parent_class)->finalize (obj);
}


GType journal_utils_get_type (void) {
	static volatile gsize journal_utils_type_id__volatile = 0;
	if (g_once_init_enter (&journal_utils_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (JournalUtilsClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) journal_utils_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (JournalUtils), 0, (GInstanceInitFunc) journal_utils_instance_init, NULL };
		GType journal_utils_type_id;
		journal_utils_type_id = g_type_register_static (G_TYPE_OBJECT, "JournalUtils", &g_define_type_info, 0);
		g_once_init_leave (&journal_utils_type_id__volatile, journal_utils_type_id);
	}
	return journal_utils_type_id__volatile;
}



